##### 切片
切片是具有相同数据类型元素的可变长度序列。<br>
<br>
切片是引用类型，内部结构包括`地址`、`长度`和`容量`<br>

##### 切片的定义
和数组类似，只是中括号内部不用写长度
```go
var 切片名 []数据类型
```
##### 切片的长度和容量
使用内置的len()函数求长度，使用内置的cap()函数求容量

##### 切片表达式
+ 简单切片表达式
切片的底层是一个数组，因此可以基于数组通过切片得到切片。<br>
<br>
注意：对切片再执行切片表达式时，`high`的上限边界是切片的容量`cap(a)`，而不是长度。<br>
```go
fun main() {
    a := [5]int{1,2,3,4,5}
    s := a[1,3] //此时s的长度是2，但是容量是4
    s2 := s[3:4] //s2的high值最大为4
}
```
+ 完整切片表达式
```go
a[low:high:max]
```


##### 使用make()函数构造切片
```go
make([]T, len, cap)
```
其中：
+ T：切片的元素类型
+ len：切片中元素长度
+ cap：切片的容量


##### 切片的本质
切片的本质是对底层数据的封装，它包含了三个信息：底层数组的指针、切片的长度和切片的容量

##### 判断切片是否为空
使用len(s)==0来判断

##### 切片不能直接进行比较
不能使用`==`操作符来判断两个切片是否含有全部相等元素。<br>
切片唯一合法的比较操作是和`nil`进行比较。


##### 切片的复制拷贝
拷贝前后两个切片共享底层数组，对一个切片的修改会影响到两一个切片的内容。

##### append()方法为切片添加元素
append()函数可以为切片动态添加元素，可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面要加...）<br>
<br>
注意：通过var声明的零值切片可以在append()函数直接使用，无需初始化

扩容策略:<br>
每个切片会指向一个底层数组，这个数组的容量够用就直接添加元素，如果容量不够用，切片会按照一定的策略进行扩容（如果原来容量为2，则增加2；如果原来容量为4，则增加4。即增加原来数组的相同大小的容量），此时该切片指向的底层数组就会更换。扩容操作往往发生在append()函数调用时，所以通常需要用原变量接收append()函数的返回值

